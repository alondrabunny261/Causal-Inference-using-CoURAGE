netcdf crgecorsfS2.b1.20241130.000000.custom {
dimensions:
	time = UNLIMITED ; // (48 currently)
	bound = 2 ;
variables:
	int base_time ;
		base_time:string = "2024-11-30 00:00:00 0:00" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
		base_time:ancillary_variables = "time_offset" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2024-11-30 00:00:00 0:00" ;
		time_offset:ancillary_variables = "base_time" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2024-11-30 00:00:00 0:00" ;
		time:standard_name = "time" ;
		time:bounds = "time_bounds" ;
	double time_bounds(time, bound) ;
		time_bounds:long_name = "Time cell bounds" ;
		time_bounds:bound_offsets = -1800., 0. ;
	float day_of_year(time) ;
		day_of_year:long_name = "Day of Year" ;
		day_of_year:units = "day" ;
		day_of_year:missing_value = -9999.f ;
	int file_records(time) ;
		file_records:long_name = "Number of file records" ;
		file_records:units = "1" ;
		file_records:missing_value = -9999 ;
	int used_records(time) ;
		used_records:long_name = "Number of file records used" ;
		used_records:units = "1" ;
		used_records:missing_value = -9999 ;
	int chopper_LI_7500(time) ;
		chopper_LI_7500:long_name = "Number of flagged records when chopper temperature in not near setpoint" ;
		chopper_LI_7500:units = "1" ;
		chopper_LI_7500:missing_value = -9999 ;
	int detector_LI_7500(time) ;
		detector_LI_7500:long_name = "Number of flagged records when detector temperature in not near setpoint" ;
		detector_LI_7500:units = "1" ;
		detector_LI_7500:missing_value = -9999 ;
	float momentum_flux(time) ;
		momentum_flux:long_name = "Corrected momentum flux" ;
		momentum_flux:units = "kg/(m s^2)" ;
		momentum_flux:missing_value = -9999.f ;
		momentum_flux:ancillary_variables = "qc_momentum_flux" ;
	int qc_momentum_flux(time) ;
		qc_momentum_flux:long_name = "Quality check results on variable: Corrected momentum flux" ;
		qc_momentum_flux:units = "1" ;
		qc_momentum_flux:standard_name = "quality_flag" ;
		qc_momentum_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_momentum_flux:fail_max = 0.f ;
		qc_momentum_flux:flag_method = "bit" ;
		qc_momentum_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_momentum_flux:bit_1_assessment = "Bad" ;
		qc_momentum_flux:bit_2_description = "Not used." ;
		qc_momentum_flux:bit_2_assessment = "Bad" ;
		qc_momentum_flux:bit_3_description = "Value is greater than fail_max." ;
		qc_momentum_flux:bit_3_assessment = "Bad" ;
		qc_momentum_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_momentum_flux:bit_4_assessment = "Bad" ;
	short flag_momentum_flux(time) ;
		flag_momentum_flux:long_name = "EddyPro quality flag for momentum_flux" ;
		flag_momentum_flux:units = "1" ;
		flag_momentum_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_momentum_flux:flag_values = 0s, 1s, 2s ;
		flag_momentum_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_momentum_flux:flag_0_description = "best quality fluxes" ;
		flag_momentum_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_momentum_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_momentum_flux:missing_value = -9999s ;
	float sensible_heat_flux(time) ;
		sensible_heat_flux:long_name = "Corrected sensible heat flux" ;
		sensible_heat_flux:units = "W/m^2" ;
		sensible_heat_flux:missing_value = -9999.f ;
		sensible_heat_flux:ancillary_variables = "qc_sensible_heat_flux" ;
		sensible_heat_flux:standard_name = "surface_upward_sensible_heat_flux" ;
	int qc_sensible_heat_flux(time) ;
		qc_sensible_heat_flux:long_name = "Quality check results on variable: Corrected sensible heat flux" ;
		qc_sensible_heat_flux:units = "1" ;
		qc_sensible_heat_flux:standard_name = "quality_flag" ;
		qc_sensible_heat_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_sensible_heat_flux:fail_min = -300.f ;
		qc_sensible_heat_flux:fail_max = 1500.f ;
		qc_sensible_heat_flux:flag_method = "bit" ;
		qc_sensible_heat_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_sensible_heat_flux:bit_1_assessment = "Bad" ;
		qc_sensible_heat_flux:bit_2_description = "Value is less than fail_min." ;
		qc_sensible_heat_flux:bit_2_assessment = "Bad" ;
		qc_sensible_heat_flux:bit_3_description = "Value is greater than fail_max." ;
		qc_sensible_heat_flux:bit_3_assessment = "Bad" ;
		qc_sensible_heat_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_sensible_heat_flux:bit_4_assessment = "Bad" ;
	short flag_sensible_heat_flux(time) ;
		flag_sensible_heat_flux:long_name = "EddyPro quality flag for sensible_heat_flux" ;
		flag_sensible_heat_flux:units = "1" ;
		flag_sensible_heat_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_sensible_heat_flux:flag_values = 0s, 1s, 2s ;
		flag_sensible_heat_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_sensible_heat_flux:flag_0_description = "best quality fluxes" ;
		flag_sensible_heat_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_sensible_heat_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_sensible_heat_flux:missing_value = -9999s ;
	float latent_flux(time) ;
		latent_flux:long_name = "Corrected latent heat flux" ;
		latent_flux:units = "W/m^2" ;
		latent_flux:missing_value = -9999.f ;
		latent_flux:ancillary_variables = "qc_latent_flux" ;
		latent_flux:standard_name = "surface_upward_latent_heat_flux" ;
	int qc_latent_flux(time) ;
		qc_latent_flux:long_name = "Quality check results on variable: Corrected latent heat flux" ;
		qc_latent_flux:units = "1" ;
		qc_latent_flux:standard_name = "quality_flag" ;
		qc_latent_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_latent_flux:fail_min = -300.f ;
		qc_latent_flux:fail_max = 1500.f ;
		qc_latent_flux:flag_method = "bit" ;
		qc_latent_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_latent_flux:bit_1_assessment = "Bad" ;
		qc_latent_flux:bit_2_description = "Value is less than fail_min." ;
		qc_latent_flux:bit_2_assessment = "Bad" ;
		qc_latent_flux:bit_3_description = "Value is greater than fail_max." ;
		qc_latent_flux:bit_3_assessment = "Bad" ;
		qc_latent_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_latent_flux:bit_4_assessment = "Bad" ;
	short flag_latent_flux(time) ;
		flag_latent_flux:long_name = "EddyPro quality flag for latent_flux" ;
		flag_latent_flux:units = "1" ;
		flag_latent_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_latent_flux:flag_values = 0s, 1s, 2s ;
		flag_latent_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_latent_flux:flag_0_description = "best quality fluxes" ;
		flag_latent_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_latent_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_latent_flux:missing_value = -9999s ;
	float co2_flux(time) ;
		co2_flux:long_name = "Corrected co2 flux" ;
		co2_flux:units = "umol/(m^2 s)" ;
		co2_flux:missing_value = -9999.f ;
		co2_flux:ancillary_variables = "qc_co2_flux" ;
		co2_flux:standard_name = "surface_upward_mole_flux_of_carbon_dioxide" ;
	int qc_co2_flux(time) ;
		qc_co2_flux:long_name = "Quality check results on variable: Corrected co2 flux" ;
		qc_co2_flux:units = "1" ;
		qc_co2_flux:standard_name = "quality_flag" ;
		qc_co2_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_co2_flux:fail_min = -50.f ;
		qc_co2_flux:fail_max = 35.f ;
		qc_co2_flux:flag_method = "bit" ;
		qc_co2_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_co2_flux:bit_1_assessment = "Bad" ;
		qc_co2_flux:bit_2_description = "Value is less than fail_min." ;
		qc_co2_flux:bit_2_assessment = "Bad" ;
		qc_co2_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_co2_flux:bit_3_assessment = "Bad" ;
		qc_co2_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_co2_flux:bit_4_assessment = "Bad" ;
	short flag_co2_flux(time) ;
		flag_co2_flux:long_name = "EddyPro quality flag for co2_flux" ;
		flag_co2_flux:units = "1" ;
		flag_co2_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_co2_flux:flag_values = 0s, 1s, 2s ;
		flag_co2_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_co2_flux:flag_0_description = "best quality fluxes" ;
		flag_co2_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_co2_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_co2_flux:missing_value = -9999s ;
	float h2o_flux(time) ;
		h2o_flux:long_name = "Corrected h2o flux" ;
		h2o_flux:units = "mmol/(m^2 s)" ;
		h2o_flux:missing_value = -9999.f ;
		h2o_flux:ancillary_variables = "qc_h2o_flux" ;
		h2o_flux:standard_name = "surface_upward_water_flux" ;
	int qc_h2o_flux(time) ;
		qc_h2o_flux:long_name = "Quality check results on variable: Corrected h2o flux" ;
		qc_h2o_flux:units = "1" ;
		qc_h2o_flux:standard_name = "quality_flag" ;
		qc_h2o_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_h2o_flux:flag_method = "bit" ;
		qc_h2o_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_h2o_flux:bit_1_assessment = "Bad" ;
		qc_h2o_flux:bit_2_description = "Not used" ;
		qc_h2o_flux:bit_2_assessment = "Bad" ;
		qc_h2o_flux:bit_3_description = "Not used" ;
		qc_h2o_flux:bit_3_assessment = "Bad" ;
		qc_h2o_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_h2o_flux:bit_4_assessment = "Bad" ;
	short flag_h2o_flux(time) ;
		flag_h2o_flux:long_name = "EddyPro quality flag for h2o_flux" ;
		flag_h2o_flux:units = "1" ;
		flag_h2o_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_h2o_flux:flag_values = 0s, 1s, 2s ;
		flag_h2o_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_h2o_flux:flag_0_description = "best quality fluxes" ;
		flag_h2o_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_h2o_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_h2o_flux:missing_value = -9999s ;
	float ch4_flux(time) ;
		ch4_flux:long_name = "Corrected ch4 flux" ;
		ch4_flux:units = "nmol/(m^2 s)" ;
		ch4_flux:missing_value = -9999.f ;
		ch4_flux:ancillary_variables = "qc_ch4_flux" ;
	int qc_ch4_flux(time) ;
		qc_ch4_flux:long_name = "Quality check results on variable: Corrected ch4 flux" ;
		qc_ch4_flux:units = "1" ;
		qc_ch4_flux:standard_name = "quality_flag" ;
		qc_ch4_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_ch4_flux:fail_min = -50.f ;
		qc_ch4_flux:fail_max = 35.f ;
		qc_ch4_flux:flag_method = "bit" ;
		qc_ch4_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_ch4_flux:bit_1_assessment = "Bad" ;
		qc_ch4_flux:bit_2_description = "Value is less than fail_min." ;
		qc_ch4_flux:bit_2_assessment = "Bad" ;
		qc_ch4_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_ch4_flux:bit_3_assessment = "Bad" ;
		qc_ch4_flux:bit_4_description = "fluxes should be discarded based on EddyPro quality flag" ;
		qc_ch4_flux:bit_4_assessment = "Bad" ;
	short flag_ch4_flux(time) ;
		flag_ch4_flux:long_name = "EddyPro quality flag for ch4_flux" ;
		flag_ch4_flux:units = "1" ;
		flag_ch4_flux:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_ch4_flux:flag_values = 0s, 1s, 2s ;
		flag_ch4_flux:flag_meanings = "best_quality_fluxes fluxes_suitable_for_general_analysis fluxes_should_be_discarded" ;
		flag_ch4_flux:flag_0_description = "best quality fluxes" ;
		flag_ch4_flux:flag_1_description = "fluxes suitable for general analysis such as annual budgets" ;
		flag_ch4_flux:flag_2_description = "fluxes should be discarded based on EddyPro quality flag" ;
		flag_ch4_flux:missing_value = -9999s ;
	float co2_molar_density(time) ;
		co2_molar_density:long_name = "Measured molar density of co2" ;
		co2_molar_density:units = "mmol/m^3" ;
		co2_molar_density:missing_value = -9999.f ;
		co2_molar_density:ancillary_variables = "qc_co2_molar_density" ;
		co2_molar_density:standard_name = "mole_concentration_of_carbon_dioxide_in_air" ;
	int qc_co2_molar_density(time) ;
		qc_co2_molar_density:long_name = "Quality check results on variable: Measured molar density of co2" ;
		qc_co2_molar_density:units = "1" ;
		qc_co2_molar_density:standard_name = "quality_flag" ;
		qc_co2_molar_density:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_co2_molar_density:fail_min = 8.f ;
		qc_co2_molar_density:fail_max = 32.f ;
		qc_co2_molar_density:flag_method = "bit" ;
		qc_co2_molar_density:bit_1_description = "Value is equal to missing_value." ;
		qc_co2_molar_density:bit_1_assessment = "Bad" ;
		qc_co2_molar_density:bit_2_description = "Value is less than fail_min." ;
		qc_co2_molar_density:bit_2_assessment = "Bad" ;
		qc_co2_molar_density:bit_3_description = "Value is greater than fail_max" ;
		qc_co2_molar_density:bit_3_assessment = "Bad" ;
	float co2_molar_fraction(time) ;
		co2_molar_fraction:long_name = "Measured molar fraction of co2" ;
		co2_molar_fraction:units = "umol/mol" ;
		co2_molar_fraction:missing_value = -9999.f ;
		co2_molar_fraction:standard_name = "mass_fraction_of_carbon_dioxide_in_air" ;
	float co2_mixing_ratio(time) ;
		co2_mixing_ratio:long_name = "Measured mixing ratio of co2" ;
		co2_mixing_ratio:units = "umol/mol" ;
		co2_mixing_ratio:missing_value = -9999.f ;
	float co2_timelag(time) ;
		co2_timelag:long_name = "Time lag used to synchronize co2 time series" ;
		co2_timelag:units = "s" ;
		co2_timelag:missing_value = -9999.f ;
	short flag_co2_timelag(time) ;
		flag_co2_timelag:long_name = "Flag whether the reported co2 time lag is the default(1) or calculated(0)" ;
		flag_co2_timelag:units = "1" ;
		flag_co2_timelag:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_co2_timelag:flag_values = 0s, 1s ;
		flag_co2_timelag:flag_meanings = "calculated default" ;
		flag_co2_timelag:flag_0_description = "calculated" ;
		flag_co2_timelag:flag_1_description = "default" ;
		flag_co2_timelag:missing_value = -9999s ;
	float h2o_molar_density(time) ;
		h2o_molar_density:long_name = "Measured molar density of h2o" ;
		h2o_molar_density:units = "mmol/m^3" ;
		h2o_molar_density:missing_value = -9999.f ;
		h2o_molar_density:ancillary_variables = "qc_h2o_molar_density" ;
	int qc_h2o_molar_density(time) ;
		qc_h2o_molar_density:long_name = "Quality check results on variable: Measured molar density of h2o" ;
		qc_h2o_molar_density:units = "1" ;
		qc_h2o_molar_density:standard_name = "quality_flag" ;
		qc_h2o_molar_density:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_h2o_molar_density:fail_min = 0.f ;
		qc_h2o_molar_density:fail_max = 2000.f ;
		qc_h2o_molar_density:flag_method = "bit" ;
		qc_h2o_molar_density:bit_1_description = "Value is equal to missing_value." ;
		qc_h2o_molar_density:bit_1_assessment = "Bad" ;
		qc_h2o_molar_density:bit_2_description = "Value is less than fail_min." ;
		qc_h2o_molar_density:bit_2_assessment = "Bad" ;
		qc_h2o_molar_density:bit_3_description = "Value is greater than fail_max" ;
		qc_h2o_molar_density:bit_3_assessment = "Bad" ;
	float h2o_mole_fraction(time) ;
		h2o_mole_fraction:long_name = "Measured molar fraction of h2o" ;
		h2o_mole_fraction:units = "mmol/mol" ;
		h2o_mole_fraction:missing_value = -9999.f ;
	float h2o_mixing_ratio(time) ;
		h2o_mixing_ratio:long_name = "Measured mixing ratio of h2o" ;
		h2o_mixing_ratio:units = "mmol/mol" ;
		h2o_mixing_ratio:missing_value = -9999.f ;
	float h2o_timelag(time) ;
		h2o_timelag:long_name = "Time lag used to synchronize h2o time series" ;
		h2o_timelag:units = "s" ;
		h2o_timelag:missing_value = -9999.f ;
	short flag_h2o_timelag(time) ;
		flag_h2o_timelag:long_name = "Flag whether the reported h2o time lag is the default(1) or calculated(0)" ;
		flag_h2o_timelag:units = "1" ;
		flag_h2o_timelag:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_h2o_timelag:flag_values = 0s, 1s ;
		flag_h2o_timelag:flag_meanings = "calculated default" ;
		flag_h2o_timelag:flag_0_description = "calculated" ;
		flag_h2o_timelag:flag_1_description = "default" ;
		flag_h2o_timelag:missing_value = -9999s ;
	float ch4_molar_density(time) ;
		ch4_molar_density:long_name = "Measured molar density of ch4" ;
		ch4_molar_density:units = "nmol/m^3" ;
		ch4_molar_density:missing_value = -9999.f ;
		ch4_molar_density:ancillary_variables = "qc_ch4_molar_density" ;
		ch4_molar_density:standard_name = "mole_concentration_of_methane_in_air" ;
	int qc_ch4_molar_density(time) ;
		qc_ch4_molar_density:long_name = "Quality check results on variable: Measured molar density of ch4" ;
		qc_ch4_molar_density:units = "1" ;
		qc_ch4_molar_density:standard_name = "quality_flag" ;
		qc_ch4_molar_density:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_ch4_molar_density:fail_min = 8.f ;
		qc_ch4_molar_density:fail_max = 32.f ;
		qc_ch4_molar_density:flag_method = "bit" ;
		qc_ch4_molar_density:bit_1_description = "Value is equal to missing_value." ;
		qc_ch4_molar_density:bit_1_assessment = "Bad" ;
		qc_ch4_molar_density:bit_2_description = "Value is less than fail_min." ;
		qc_ch4_molar_density:bit_2_assessment = "Bad" ;
		qc_ch4_molar_density:bit_3_description = "Value is greater than fail_max" ;
		qc_ch4_molar_density:bit_3_assessment = "Bad" ;
	float ch4_mole_fraction(time) ;
		ch4_mole_fraction:long_name = "Measured molar fraction of ch4" ;
		ch4_mole_fraction:units = "nmol/mol" ;
		ch4_mole_fraction:missing_value = -9999.f ;
		ch4_mole_fraction:standard_name = "mass_fraction_of_methane_in_air" ;
	float ch4_mixing_ratio(time) ;
		ch4_mixing_ratio:long_name = "Measured mixing ratio of ch4" ;
		ch4_mixing_ratio:units = "nmol/mol" ;
		ch4_mixing_ratio:missing_value = -9999.f ;
	float ch4_timelag(time) ;
		ch4_timelag:long_name = "Time lag used to synchronize ch4 time series" ;
		ch4_timelag:units = "s" ;
		ch4_timelag:missing_value = -9999.f ;
	short flag_ch4_timelag(time) ;
		flag_ch4_timelag:long_name = "Flag whether the reported ch4 time lag is the default(1) or calculated(0)" ;
		flag_ch4_timelag:units = "1" ;
		flag_ch4_timelag:description = "This field contains short integer values which should be interpreted as follows:" ;
		flag_ch4_timelag:flag_values = 0s, 1s ;
		flag_ch4_timelag:flag_meanings = "calculated default" ;
		flag_ch4_timelag:flag_0_description = "calculated" ;
		flag_ch4_timelag:flag_1_description = "default" ;
		flag_ch4_timelag:missing_value = -9999s ;
	float sonic_temperature(time) ;
		sonic_temperature:long_name = "Mean temperature of ambient air measured by the anemometer, ts" ;
		sonic_temperature:units = "K" ;
		sonic_temperature:missing_value = -9999.f ;
		sonic_temperature:ancillary_variables = "qc_sonic_temperature" ;
		sonic_temperature:standard_name = "air_temperature" ;
	int qc_sonic_temperature(time) ;
		qc_sonic_temperature:long_name = "Quality check results on variable: Mean temperature of ambient air measured by the anemometer, ts" ;
		qc_sonic_temperature:units = "1" ;
		qc_sonic_temperature:standard_name = "quality_flag" ;
		qc_sonic_temperature:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_sonic_temperature:fail_min = 234.f ;
		qc_sonic_temperature:fail_max = 335.f ;
		qc_sonic_temperature:flag_method = "bit" ;
		qc_sonic_temperature:bit_1_description = "Value is equal to missing_value." ;
		qc_sonic_temperature:bit_1_assessment = "Bad" ;
		qc_sonic_temperature:bit_2_description = "Value is less than fail_min." ;
		qc_sonic_temperature:bit_2_assessment = "Bad" ;
		qc_sonic_temperature:bit_3_description = "Value is greater than fail_max" ;
		qc_sonic_temperature:bit_3_assessment = "Bad" ;
	float air_temperature(time) ;
		air_temperature:long_name = "Mean temperature of ambient air, calculated from high frequency air temperature readings" ;
		air_temperature:units = "K" ;
		air_temperature:missing_value = -9999.f ;
		air_temperature:ancillary_variables = "qc_air_temperature" ;
		air_temperature:standard_name = "air_temperature" ;
	int qc_air_temperature(time) ;
		qc_air_temperature:long_name = "Quality check results on variable: Mean temperature of ambient air, calculated from high frequency air temperature readings" ;
		qc_air_temperature:units = "1" ;
		qc_air_temperature:standard_name = "quality_flag" ;
		qc_air_temperature:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_air_temperature:fail_min = 243.f ;
		qc_air_temperature:fail_max = 333.f ;
		qc_air_temperature:flag_method = "bit" ;
		qc_air_temperature:bit_1_description = "Value is equal to missing_value." ;
		qc_air_temperature:bit_1_assessment = "Bad" ;
		qc_air_temperature:bit_2_description = "Value is less than fail_min." ;
		qc_air_temperature:bit_2_assessment = "Bad" ;
		qc_air_temperature:bit_3_description = "Value is greater than fail_max" ;
		qc_air_temperature:bit_3_assessment = "Bad" ;
	float air_pressure(time) ;
		air_pressure:long_name = "Mean pressure of ambient air, calculated from high frequency air pressure readings" ;
		air_pressure:units = "kPa" ;
		air_pressure:missing_value = -9999.f ;
		air_pressure:ancillary_variables = "qc_air_pressure" ;
		air_pressure:standard_name = "air_pressure" ;
	int qc_air_pressure(time) ;
		qc_air_pressure:long_name = "Quality check results on variable: Mean pressure of ambient air, calculated from high frequency air pressure readings" ;
		qc_air_pressure:units = "1" ;
		qc_air_pressure:standard_name = "quality_flag" ;
		qc_air_pressure:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_air_pressure:fail_min = 80.f ;
		qc_air_pressure:fail_max = 110.f ;
		qc_air_pressure:flag_method = "bit" ;
		qc_air_pressure:bit_1_description = "Value is equal to missing_value." ;
		qc_air_pressure:bit_1_assessment = "Bad" ;
		qc_air_pressure:bit_2_description = "Value is less than fail_min." ;
		qc_air_pressure:bit_2_assessment = "Bad" ;
		qc_air_pressure:bit_3_description = "Value is greater than fail_max" ;
		qc_air_pressure:bit_3_assessment = "Bad" ;
	float air_density(time) ;
		air_density:long_name = "Density of ambient air" ;
		air_density:units = "kg/m^3" ;
		air_density:missing_value = -9999.f ;
		air_density:ancillary_variables = "qc_air_density" ;
		air_density:standard_name = "air_density" ;
	int qc_air_density(time) ;
		qc_air_density:long_name = "Quality check results on variable: Density of ambient air" ;
		qc_air_density:units = "1" ;
		qc_air_density:standard_name = "quality_flag" ;
		qc_air_density:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_air_density:fail_min = 1.f ;
		qc_air_density:fail_max = 1.35f ;
		qc_air_density:flag_method = "bit" ;
		qc_air_density:bit_1_description = "Value is equal to missing_value." ;
		qc_air_density:bit_1_assessment = "Bad" ;
		qc_air_density:bit_2_description = "Value is less than fail_min." ;
		qc_air_density:bit_2_assessment = "Bad" ;
		qc_air_density:bit_3_description = "Value is greater than fail_max" ;
		qc_air_density:bit_3_assessment = "Bad" ;
	float air_heat_capacity(time) ;
		air_heat_capacity:long_name = "Specific heat at constant pressure of ambient air" ;
		air_heat_capacity:units = "J/(kg K)" ;
		air_heat_capacity:missing_value = -9999.f ;
		air_heat_capacity:ancillary_variables = "qc_air_heat_capacity" ;
	int qc_air_heat_capacity(time) ;
		qc_air_heat_capacity:long_name = "Quality check results on variable: Specific heat at constant pressure of ambient air" ;
		qc_air_heat_capacity:units = "1" ;
		qc_air_heat_capacity:standard_name = "quality_flag" ;
		qc_air_heat_capacity:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_air_heat_capacity:fail_min = 1006.f ;
		qc_air_heat_capacity:fail_max = 1122.f ;
		qc_air_heat_capacity:flag_method = "bit" ;
		qc_air_heat_capacity:bit_1_description = "Value is equal to missing_value." ;
		qc_air_heat_capacity:bit_1_assessment = "Bad" ;
		qc_air_heat_capacity:bit_2_description = "Value is less than fail_min." ;
		qc_air_heat_capacity:bit_2_assessment = "Bad" ;
		qc_air_heat_capacity:bit_3_description = "Value is greater than fail_max" ;
		qc_air_heat_capacity:bit_3_assessment = "Bad" ;
	float air_molar_volume(time) ;
		air_molar_volume:long_name = "Molar volume of ambient air" ;
		air_molar_volume:units = "m^3/mol" ;
		air_molar_volume:missing_value = -9999.f ;
	float evapotranspiration_flux(time) ;
		evapotranspiration_flux:long_name = "Evapotranspiration flux" ;
		evapotranspiration_flux:units = "mm/hr" ;
		evapotranspiration_flux:missing_value = -9999.f ;
	float water_vapor_density(time) ;
		water_vapor_density:long_name = "Ambient mass density of water vapor" ;
		water_vapor_density:units = "kg/m^3" ;
		water_vapor_density:missing_value = -9999.f ;
		water_vapor_density:standard_name = "mass_concentration_of_water_vapor_in_air" ;
	float water_vapor_partial_pressure(time) ;
		water_vapor_partial_pressure:long_name = "Ambient water vapor partial pressure" ;
		water_vapor_partial_pressure:units = "kPa" ;
		water_vapor_partial_pressure:missing_value = -9999.f ;
		water_vapor_partial_pressure:standard_name = "water_vapor_partial_pressure_in_air" ;
	float water_vapor_partial_pressure_saturated(time) ;
		water_vapor_partial_pressure_saturated:long_name = "Ambient water vapor partial pressure at saturation" ;
		water_vapor_partial_pressure_saturated:units = "kPa" ;
		water_vapor_partial_pressure_saturated:missing_value = -9999.f ;
	float specific_humidity(time) ;
		specific_humidity:long_name = "Ambient specific humidity on a mass basis" ;
		specific_humidity:units = "kg/kg" ;
		specific_humidity:missing_value = -9999.f ;
		specific_humidity:standard_name = "specific_humidity" ;
	float relative_humidity(time) ;
		relative_humidity:long_name = "Ambient relative humidity" ;
		relative_humidity:units = "%" ;
		relative_humidity:missing_value = -9999.f ;
		relative_humidity:standard_name = "relative_humidity" ;
	float water_vapor_pressure_deficit(time) ;
		water_vapor_pressure_deficit:long_name = "Ambient water vapor pressure deficit" ;
		water_vapor_pressure_deficit:units = "kPa" ;
		water_vapor_pressure_deficit:missing_value = -9999.f ;
	float dew_point_temperature(time) ;
		dew_point_temperature:long_name = "Ambient dew point temperature" ;
		dew_point_temperature:units = "K" ;
		dew_point_temperature:missing_value = -9999.f ;
		dew_point_temperature:standard_name = "dew_point_temperature" ;
	float wind_u_component(time) ;
		wind_u_component:long_name = "Wind component along the u anemometer axis" ;
		wind_u_component:units = "m/s" ;
		wind_u_component:missing_value = -9999.f ;
		wind_u_component:ancillary_variables = "qc_wind_u_component" ;
	int qc_wind_u_component(time) ;
		qc_wind_u_component:long_name = "Quality check results on variable: Wind component along the u anemometer axis" ;
		qc_wind_u_component:units = "1" ;
		qc_wind_u_component:standard_name = "quality_flag" ;
		qc_wind_u_component:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_wind_u_component:fail_min = -30.f ;
		qc_wind_u_component:fail_max = 30.f ;
		qc_wind_u_component:flag_method = "bit" ;
		qc_wind_u_component:bit_1_description = "Value is equal to missing_value." ;
		qc_wind_u_component:bit_1_assessment = "Bad" ;
		qc_wind_u_component:bit_2_description = "Value is less than fail_min." ;
		qc_wind_u_component:bit_2_assessment = "Bad" ;
		qc_wind_u_component:bit_3_description = "Value is greater than fail_max" ;
		qc_wind_u_component:bit_3_assessment = "Bad" ;
	float wind_v_component(time) ;
		wind_v_component:long_name = "Wind component along the v anemometer axis" ;
		wind_v_component:units = "m/s" ;
		wind_v_component:missing_value = -9999.f ;
		wind_v_component:ancillary_variables = "qc_wind_v_component" ;
	int qc_wind_v_component(time) ;
		qc_wind_v_component:long_name = "Quality check results on variable: Wind component along the v anemometer axis" ;
		qc_wind_v_component:units = "1" ;
		qc_wind_v_component:standard_name = "quality_flag" ;
		qc_wind_v_component:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_wind_v_component:fail_min = -30.f ;
		qc_wind_v_component:fail_max = 30.f ;
		qc_wind_v_component:flag_method = "bit" ;
		qc_wind_v_component:bit_1_description = "Value is equal to missing_value." ;
		qc_wind_v_component:bit_1_assessment = "Bad" ;
		qc_wind_v_component:bit_2_description = "Value is less than fail_min." ;
		qc_wind_v_component:bit_2_assessment = "Bad" ;
		qc_wind_v_component:bit_3_description = "Value is greater than fail_max" ;
		qc_wind_v_component:bit_3_assessment = "Bad" ;
	float wind_w_component(time) ;
		wind_w_component:long_name = "Wind component along the w anemometer axis" ;
		wind_w_component:units = "m/s" ;
		wind_w_component:missing_value = -9999.f ;
		wind_w_component:ancillary_variables = "qc_wind_w_component" ;
		wind_w_component:standard_name = "upward_air_velocity" ;
	int qc_wind_w_component(time) ;
		qc_wind_w_component:long_name = "Quality check results on variable: Wind component along the w anemometer axis" ;
		qc_wind_w_component:units = "1" ;
		qc_wind_w_component:standard_name = "quality_flag" ;
		qc_wind_w_component:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_wind_w_component:fail_min = -30.f ;
		qc_wind_w_component:fail_max = 30.f ;
		qc_wind_w_component:flag_method = "bit" ;
		qc_wind_w_component:bit_1_description = "Value is equal to missing_value." ;
		qc_wind_w_component:bit_1_assessment = "Bad" ;
		qc_wind_w_component:bit_2_description = "Value is less than fail_min." ;
		qc_wind_w_component:bit_2_assessment = "Bad" ;
		qc_wind_w_component:bit_3_description = "Value is greater than fail_max" ;
		qc_wind_w_component:bit_3_assessment = "Bad" ;
	float rotated_mean_u(time) ;
		rotated_mean_u:long_name = "Rotated u wind component (mean wind speed)" ;
		rotated_mean_u:units = "m/s" ;
		rotated_mean_u:missing_value = -9999.f ;
	float rotated_mean_v(time) ;
		rotated_mean_v:long_name = "Rotated v wind component (should be zero)" ;
		rotated_mean_v:units = "m/s" ;
		rotated_mean_v:missing_value = -9999.f ;
	float rotated_mean_w(time) ;
		rotated_mean_w:long_name = "Rotated w wind component (should be zero)" ;
		rotated_mean_w:units = "m/s" ;
		rotated_mean_w:missing_value = -9999.f ;
	float mean_wind(time) ;
		mean_wind:long_name = "Mean wind speed" ;
		mean_wind:units = "m/s" ;
		mean_wind:missing_value = -9999.f ;
		mean_wind:ancillary_variables = "qc_mean_wind" ;
		mean_wind:standard_name = "wind_speed" ;
	int qc_mean_wind(time) ;
		qc_mean_wind:long_name = "Quality check results on variable: Mean wind speed" ;
		qc_mean_wind:units = "1" ;
		qc_mean_wind:standard_name = "quality_flag" ;
		qc_mean_wind:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_mean_wind:fail_min = 0.f ;
		qc_mean_wind:fail_max = 42.f ;
		qc_mean_wind:flag_method = "bit" ;
		qc_mean_wind:bit_1_description = "Value is equal to missing_value." ;
		qc_mean_wind:bit_1_assessment = "Bad" ;
		qc_mean_wind:bit_2_description = "Value is less than fail_min." ;
		qc_mean_wind:bit_2_assessment = "Bad" ;
		qc_mean_wind:bit_3_description = "Value is greater than fail_max" ;
		qc_mean_wind:bit_3_assessment = "Bad" ;
	float maximum_instantaneous_wind_speed(time) ;
		maximum_instantaneous_wind_speed:long_name = "Maximum instantaneous wind speed" ;
		maximum_instantaneous_wind_speed:units = "m/s" ;
		maximum_instantaneous_wind_speed:missing_value = -9999.f ;
		maximum_instantaneous_wind_speed:standard_name = "wind_speed_of_gust" ;
	float wind_direction_from_north(time) ;
		wind_direction_from_north:long_name = "Direction from which the wind blows, with respect to Geographic north" ;
		wind_direction_from_north:units = "degree" ;
		wind_direction_from_north:missing_value = -9999.f ;
		wind_direction_from_north:ancillary_variables = "qc_wind_direction_from_north" ;
		wind_direction_from_north:standard_name = "wind_from_direction" ;
	int qc_wind_direction_from_north(time) ;
		qc_wind_direction_from_north:long_name = "Quality check results on variable: Direction from which the wind blows, with respect to Geographic north" ;
		qc_wind_direction_from_north:units = "1" ;
		qc_wind_direction_from_north:standard_name = "quality_flag" ;
		qc_wind_direction_from_north:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_wind_direction_from_north:fail_min = 0.f ;
		qc_wind_direction_from_north:fail_max = 360.f ;
		qc_wind_direction_from_north:flag_method = "bit" ;
		qc_wind_direction_from_north:bit_1_description = "Value is equal to missing_value." ;
		qc_wind_direction_from_north:bit_1_assessment = "Bad" ;
		qc_wind_direction_from_north:bit_2_description = "Value is less than fail_min." ;
		qc_wind_direction_from_north:bit_2_assessment = "Bad" ;
		qc_wind_direction_from_north:bit_3_description = "Value is greater than fail_max" ;
		qc_wind_direction_from_north:bit_3_assessment = "Bad" ;
	float first_rotation_angle(time) ;
		first_rotation_angle:long_name = "First rotation angle" ;
		first_rotation_angle:units = "degree" ;
		first_rotation_angle:missing_value = -9999.f ;
	float second_rotation_angle(time) ;
		second_rotation_angle:long_name = "Second rotation angle" ;
		second_rotation_angle:units = "degree" ;
		second_rotation_angle:missing_value = -9999.f ;
	float friction_velocity(time) ;
		friction_velocity:long_name = "Friction velocity" ;
		friction_velocity:units = "m/s" ;
		friction_velocity:missing_value = -9999.f ;
		friction_velocity:ancillary_variables = "qc_friction_velocity" ;
	int qc_friction_velocity(time) ;
		qc_friction_velocity:long_name = "Quality check results on variable: Friction velocity" ;
		qc_friction_velocity:units = "1" ;
		qc_friction_velocity:standard_name = "quality_flag" ;
		qc_friction_velocity:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_friction_velocity:fail_min = 0.02f ;
		qc_friction_velocity:fail_max = 1.5f ;
		qc_friction_velocity:flag_method = "bit" ;
		qc_friction_velocity:bit_1_description = "Value is equal to missing_value." ;
		qc_friction_velocity:bit_1_assessment = "Bad" ;
		qc_friction_velocity:bit_2_description = "Value is less than fail_min." ;
		qc_friction_velocity:bit_2_assessment = "Bad" ;
		qc_friction_velocity:bit_3_description = "Value is greater than fail_max" ;
		qc_friction_velocity:bit_3_assessment = "Bad" ;
	float turbulent_kinetic_energy(time) ;
		turbulent_kinetic_energy:long_name = "Turbulent kinetic energy" ;
		turbulent_kinetic_energy:units = "m^2/s^2" ;
		turbulent_kinetic_energy:missing_value = -9999.f ;
	float Monin_Obukhov_length(time) ;
		Monin_Obukhov_length:long_name = "Monin_Obukhov length" ;
		Monin_Obukhov_length:units = "m" ;
		Monin_Obukhov_length:missing_value = -9999.f ;
	float Monin_Obukhov_stability_parameter(time) ;
		Monin_Obukhov_stability_parameter:long_name = "Monin_Obukhov stability parameter" ;
		Monin_Obukhov_stability_parameter:units = "1" ;
		Monin_Obukhov_stability_parameter:missing_value = -9999.f ;
	float Bowen_ratio(time) ;
		Bowen_ratio:long_name = "Sensible heat flux to latent heat flux ratio" ;
		Bowen_ratio:units = "1" ;
		Bowen_ratio:missing_value = -9999.f ;
	float scaling_temperature(time) ;
		scaling_temperature:long_name = "Scaling temperature" ;
		scaling_temperature:units = "K" ;
		scaling_temperature:missing_value = -9999.f ;
	float uncorrected_momentum_flux(time) ;
		uncorrected_momentum_flux:long_name = "Uncorrected momentum flux" ;
		uncorrected_momentum_flux:units = "kg/(m s^2)" ;
		uncorrected_momentum_flux:missing_value = -9999.f ;
	float spectral_correction_momentum_flux(time) ;
		spectral_correction_momentum_flux:long_name = "Spectral correction factor for momentum flux" ;
		spectral_correction_momentum_flux:units = "1" ;
		spectral_correction_momentum_flux:missing_value = -9999.f ;
	float uncorrected_sensible_heat_flux(time) ;
		uncorrected_sensible_heat_flux:long_name = "Uncorrected sensible heat flux" ;
		uncorrected_sensible_heat_flux:units = "W/m^2" ;
		uncorrected_sensible_heat_flux:missing_value = -9999.f ;
		uncorrected_sensible_heat_flux:ancillary_variables = "qc_uncorrected_sensible_heat_flux" ;
	int qc_uncorrected_sensible_heat_flux(time) ;
		qc_uncorrected_sensible_heat_flux:long_name = "Quality check results on variable: Uncorrected sensible heat flux" ;
		qc_uncorrected_sensible_heat_flux:units = "1" ;
		qc_uncorrected_sensible_heat_flux:standard_name = "quality_flag" ;
		qc_uncorrected_sensible_heat_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_uncorrected_sensible_heat_flux:fail_min = -300.f ;
		qc_uncorrected_sensible_heat_flux:fail_max = 1500.f ;
		qc_uncorrected_sensible_heat_flux:flag_method = "bit" ;
		qc_uncorrected_sensible_heat_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_uncorrected_sensible_heat_flux:bit_1_assessment = "Bad" ;
		qc_uncorrected_sensible_heat_flux:bit_2_description = "Value is less than fail_min." ;
		qc_uncorrected_sensible_heat_flux:bit_2_assessment = "Bad" ;
		qc_uncorrected_sensible_heat_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_uncorrected_sensible_heat_flux:bit_3_assessment = "Bad" ;
	float spectral_correction_sensible_heat_flux(time) ;
		spectral_correction_sensible_heat_flux:long_name = "Spectral correction factor for sensible heat flux" ;
		spectral_correction_sensible_heat_flux:units = "1" ;
		spectral_correction_sensible_heat_flux:missing_value = -9999.f ;
	float uncorrected_latent_heat_flux(time) ;
		uncorrected_latent_heat_flux:long_name = "Uncorrected latent heat flux" ;
		uncorrected_latent_heat_flux:units = "W/m^2" ;
		uncorrected_latent_heat_flux:missing_value = -9999.f ;
		uncorrected_latent_heat_flux:ancillary_variables = "qc_uncorrected_latent_heat_flux" ;
	int qc_uncorrected_latent_heat_flux(time) ;
		qc_uncorrected_latent_heat_flux:long_name = "Quality check results on variable: Uncorrected latent heat flux" ;
		qc_uncorrected_latent_heat_flux:units = "1" ;
		qc_uncorrected_latent_heat_flux:standard_name = "quality_flag" ;
		qc_uncorrected_latent_heat_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_uncorrected_latent_heat_flux:fail_min = -300.f ;
		qc_uncorrected_latent_heat_flux:fail_max = 1500.f ;
		qc_uncorrected_latent_heat_flux:flag_method = "bit" ;
		qc_uncorrected_latent_heat_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_uncorrected_latent_heat_flux:bit_1_assessment = "Bad" ;
		qc_uncorrected_latent_heat_flux:bit_2_description = "Value is less than fail_min." ;
		qc_uncorrected_latent_heat_flux:bit_2_assessment = "Bad" ;
		qc_uncorrected_latent_heat_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_uncorrected_latent_heat_flux:bit_3_assessment = "Bad" ;
	float spectral_correction_latent_heat_flux(time) ;
		spectral_correction_latent_heat_flux:long_name = "Spectral correction factor for latent heat flux" ;
		spectral_correction_latent_heat_flux:units = "1" ;
		spectral_correction_latent_heat_flux:missing_value = -9999.f ;
	float uncorrected_co2_flux(time) ;
		uncorrected_co2_flux:long_name = "Uncorrected co2 flux" ;
		uncorrected_co2_flux:units = "umol/(m^2 s)" ;
		uncorrected_co2_flux:missing_value = -9999.f ;
		uncorrected_co2_flux:ancillary_variables = "qc_uncorrected_co2_flux" ;
	int qc_uncorrected_co2_flux(time) ;
		qc_uncorrected_co2_flux:long_name = "Quality check results on variable: Uncorrected co2 flux" ;
		qc_uncorrected_co2_flux:units = "1" ;
		qc_uncorrected_co2_flux:standard_name = "quality_flag" ;
		qc_uncorrected_co2_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_uncorrected_co2_flux:fail_min = -50.f ;
		qc_uncorrected_co2_flux:fail_max = 35.f ;
		qc_uncorrected_co2_flux:flag_method = "bit" ;
		qc_uncorrected_co2_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_uncorrected_co2_flux:bit_1_assessment = "Bad" ;
		qc_uncorrected_co2_flux:bit_2_description = "Value is less than fail_min." ;
		qc_uncorrected_co2_flux:bit_2_assessment = "Bad" ;
		qc_uncorrected_co2_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_uncorrected_co2_flux:bit_3_assessment = "Bad" ;
	float spectral_correction_co2_flux(time) ;
		spectral_correction_co2_flux:long_name = "Spectral correction factor for co2 flux" ;
		spectral_correction_co2_flux:units = "1" ;
		spectral_correction_co2_flux:missing_value = -9999.f ;
	float uncorrected_h2o_flux(time) ;
		uncorrected_h2o_flux:long_name = "Uncorrected h2o flux" ;
		uncorrected_h2o_flux:units = "mmol/(m^2 s)" ;
		uncorrected_h2o_flux:missing_value = -9999.f ;
	float spectral_correction_h2o_flux(time) ;
		spectral_correction_h2o_flux:long_name = "Spectral correction factor for h2o flux" ;
		spectral_correction_h2o_flux:units = "1" ;
		spectral_correction_h2o_flux:missing_value = -9999.f ;
	float uncorrected_ch4_flux(time) ;
		uncorrected_ch4_flux:long_name = "Uncorrected ch4 flux" ;
		uncorrected_ch4_flux:units = "nmol/(m^2 s)" ;
		uncorrected_ch4_flux:missing_value = -9999.f ;
		uncorrected_ch4_flux:ancillary_variables = "qc_uncorrected_ch4_flux" ;
	int qc_uncorrected_ch4_flux(time) ;
		qc_uncorrected_ch4_flux:long_name = "Quality check results on variable: Uncorrected ch4 flux" ;
		qc_uncorrected_ch4_flux:units = "1" ;
		qc_uncorrected_ch4_flux:standard_name = "quality_flag" ;
		qc_uncorrected_ch4_flux:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_uncorrected_ch4_flux:fail_min = -50.f ;
		qc_uncorrected_ch4_flux:fail_max = 35.f ;
		qc_uncorrected_ch4_flux:flag_method = "bit" ;
		qc_uncorrected_ch4_flux:bit_1_description = "Value is equal to missing_value." ;
		qc_uncorrected_ch4_flux:bit_1_assessment = "Bad" ;
		qc_uncorrected_ch4_flux:bit_2_description = "Value is less than fail_min." ;
		qc_uncorrected_ch4_flux:bit_2_assessment = "Bad" ;
		qc_uncorrected_ch4_flux:bit_3_description = "Value is greater than fail_max" ;
		qc_uncorrected_ch4_flux:bit_3_assessment = "Bad" ;
	float spectral_correction_ch4_flux(time) ;
		spectral_correction_ch4_flux:long_name = "Spectral correction factor for ch4 flux" ;
		spectral_correction_ch4_flux:units = "1" ;
		spectral_correction_ch4_flux:missing_value = -9999.f ;
	int hard_flags_spike_test(time) ;
		hard_flags_spike_test:long_name = "Hard flags for spike test" ;
		hard_flags_spike_test:units = "1" ;
		hard_flags_spike_test:missing_value = -9999 ;
		hard_flags_spike_test:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_resolution(time) ;
		hard_flags_resolution:long_name = "Hard flags for amplitude resolution" ;
		hard_flags_resolution:units = "1" ;
		hard_flags_resolution:missing_value = -9999 ;
		hard_flags_resolution:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_drop_out_test(time) ;
		hard_flags_drop_out_test:long_name = "Hard flags for drop_out test" ;
		hard_flags_drop_out_test:units = "1" ;
		hard_flags_drop_out_test:missing_value = -9999 ;
		hard_flags_drop_out_test:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_absolute_limits(time) ;
		hard_flags_absolute_limits:long_name = "Hard flags for absolute limits" ;
		hard_flags_absolute_limits:units = "1" ;
		hard_flags_absolute_limits:missing_value = -9999 ;
		hard_flags_absolute_limits:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_skewness_kurtosis(time) ;
		hard_flags_skewness_kurtosis:long_name = "Hard flags for skewness and kurtosis test" ;
		hard_flags_skewness_kurtosis:units = "1" ;
		hard_flags_skewness_kurtosis:missing_value = -9999 ;
		hard_flags_skewness_kurtosis:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int soft_flags_skewness_kurtosis(time) ;
		soft_flags_skewness_kurtosis:long_name = "Soft flags for skewness and kurtosis test" ;
		soft_flags_skewness_kurtosis:units = "1" ;
		soft_flags_skewness_kurtosis:missing_value = -9999 ;
		soft_flags_skewness_kurtosis:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_discontinuities_test(time) ;
		hard_flags_discontinuities_test:long_name = "Hard flags for discontinuities test" ;
		hard_flags_discontinuities_test:units = "1" ;
		hard_flags_discontinuities_test:missing_value = -9999 ;
		hard_flags_discontinuities_test:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int soft_flags_discontinuities_test(time) ;
		soft_flags_discontinuities_test:long_name = "Soft flags for discontinuities test" ;
		soft_flags_discontinuities_test:units = "1" ;
		soft_flags_discontinuities_test:missing_value = -9999 ;
		soft_flags_discontinuities_test:comment = "This flag is always 9 digits long. Each digit represents a flag for a different variable (8/u/v/w/ts/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 801000099 would translate to the \"v\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_time_lag_test(time) ;
		hard_flags_time_lag_test:long_name = "Hard flags for time lag test" ;
		hard_flags_time_lag_test:units = "1" ;
		hard_flags_time_lag_test:missing_value = -9999 ;
		hard_flags_time_lag_test:comment = "This flag is always 5 digits long. Each digit represents a flag for a different variable (8/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 80199 would translate to the \"h2o\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int soft_flags_time_lag_test(time) ;
		soft_flags_time_lag_test:long_name = "Soft flags for time lag test" ;
		soft_flags_time_lag_test:units = "1" ;
		soft_flags_time_lag_test:missing_value = -9999 ;
		soft_flags_time_lag_test:comment = "This flag is always 5 digits long. Each digit represents a flag for a different variable (8/co2/h2o/ch4/none), with the first digit set to 8 to preserve the zeros when no variables are flagged. For example 80199 would translate to the \"h2o\" variable being flagged and \"ch4\" and \"none\" missing. Note \"none\" is a placeholder if there was an additional/non-default variable being measured." ;
	int hard_flags_attack_angle_test(time) ;
		hard_flags_attack_angle_test:long_name = "Hard flags for attack angle test" ;
		hard_flags_attack_angle_test:units = "1" ;
		hard_flags_attack_angle_test:missing_value = -9999 ;
		hard_flags_attack_angle_test:comment = "This flag is always 2 digits long. The first digit is always set to 8 to preserve the zero when no variables are flagged, and the second digit is the flag." ;
	int hard_flags_non_steady_wind(time) ;
		hard_flags_non_steady_wind:long_name = "Hard flags for non steady horizontal wind test" ;
		hard_flags_non_steady_wind:units = "1" ;
		hard_flags_non_steady_wind:missing_value = -9999 ;
		hard_flags_non_steady_wind:comment = "This flag is always 2 digits long. The first digit is always set to 8 to preserve the zero when no variables are flagged, and the second digit is the flag." ;
	float number_spikes_u(time) ;
		number_spikes_u:long_name = "Number of spikes detected and eliminated for u" ;
		number_spikes_u:units = "1" ;
		number_spikes_u:missing_value = -9999.f ;
	float number_spikes_v(time) ;
		number_spikes_v:long_name = "Number of spikes detected and eliminated for v" ;
		number_spikes_v:units = "1" ;
		number_spikes_v:missing_value = -9999.f ;
	float number_spikes_w(time) ;
		number_spikes_w:long_name = "Number of spikes detected and eliminated for w" ;
		number_spikes_w:units = "1" ;
		number_spikes_w:missing_value = -9999.f ;
	float number_spikes_ts(time) ;
		number_spikes_ts:long_name = "Number of spikes detected and eliminated for ts" ;
		number_spikes_ts:units = "1" ;
		number_spikes_ts:missing_value = -9999.f ;
	float number_spikes_co2(time) ;
		number_spikes_co2:long_name = "Number of spikes detected and eliminated for co2" ;
		number_spikes_co2:units = "1" ;
		number_spikes_co2:missing_value = -9999.f ;
	float number_spikes_h2o(time) ;
		number_spikes_h2o:long_name = "Number of spikes detected and eliminated for h2o" ;
		number_spikes_h2o:units = "1" ;
		number_spikes_h2o:missing_value = -9999.f ;
	float number_spikes_ch4(time) ;
		number_spikes_ch4:long_name = "Number of spikes detected and eliminated for ch4" ;
		number_spikes_ch4:units = "1" ;
		number_spikes_ch4:missing_value = -9999.f ;
	int phase_lock_flag_LI_7500(time) ;
		phase_lock_flag_LI_7500:long_name = "Number of flagged records when optical filter wheel is not rotating at the correct rate" ;
		phase_lock_flag_LI_7500:units = "1" ;
		phase_lock_flag_LI_7500:missing_value = -9999 ;
	int sync_flag_LI_7500(time) ;
		sync_flag_LI_7500:long_name = "Number of flagged records when sync flag is not set to 1 (normal)" ;
		sync_flag_LI_7500:units = "1" ;
		sync_flag_LI_7500:missing_value = -9999 ;
	float mean_value_LI_7500(time) ;
		mean_value_LI_7500:long_name = "Mean value LI_7500" ;
		mean_value_LI_7500:units = "1" ;
		mean_value_LI_7500:missing_value = -9999.f ;
	float variance_u(time) ;
		variance_u:long_name = "Variance of u" ;
		variance_u:units = "m^2/s^2" ;
		variance_u:missing_value = -9999.f ;
		variance_u:ancillary_variables = "qc_variance_u" ;
	int qc_variance_u(time) ;
		qc_variance_u:long_name = "Quality check results on variable: Variance of u" ;
		qc_variance_u:units = "1" ;
		qc_variance_u:standard_name = "quality_flag" ;
		qc_variance_u:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_u:fail_min = 0.001f ;
		qc_variance_u:fail_max = 5.f ;
		qc_variance_u:flag_method = "bit" ;
		qc_variance_u:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_u:bit_1_assessment = "Bad" ;
		qc_variance_u:bit_2_description = "Value is less than fail_min." ;
		qc_variance_u:bit_2_assessment = "Bad" ;
		qc_variance_u:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_u:bit_3_assessment = "Bad" ;
	float variance_v(time) ;
		variance_v:long_name = "Variance of v" ;
		variance_v:units = "m^2/s^2" ;
		variance_v:missing_value = -9999.f ;
		variance_v:ancillary_variables = "qc_variance_v" ;
	int qc_variance_v(time) ;
		qc_variance_v:long_name = "Quality check results on variable: Variance of v" ;
		qc_variance_v:units = "1" ;
		qc_variance_v:standard_name = "quality_flag" ;
		qc_variance_v:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_v:fail_min = 0.001f ;
		qc_variance_v:fail_max = 5.f ;
		qc_variance_v:flag_method = "bit" ;
		qc_variance_v:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_v:bit_1_assessment = "Bad" ;
		qc_variance_v:bit_2_description = "Value is less than fail_min." ;
		qc_variance_v:bit_2_assessment = "Bad" ;
		qc_variance_v:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_v:bit_3_assessment = "Bad" ;
	float variance_w(time) ;
		variance_w:long_name = "Variance of w" ;
		variance_w:units = "m^2/s^2" ;
		variance_w:missing_value = -9999.f ;
		variance_w:ancillary_variables = "qc_variance_w" ;
	int qc_variance_w(time) ;
		qc_variance_w:long_name = "Quality check results on variable: Variance of w" ;
		qc_variance_w:units = "1" ;
		qc_variance_w:standard_name = "quality_flag" ;
		qc_variance_w:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_w:fail_min = 0.001f ;
		qc_variance_w:fail_max = 3.f ;
		qc_variance_w:flag_method = "bit" ;
		qc_variance_w:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_w:bit_1_assessment = "Bad" ;
		qc_variance_w:bit_2_description = "Value is less than fail_min." ;
		qc_variance_w:bit_2_assessment = "Bad" ;
		qc_variance_w:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_w:bit_3_assessment = "Bad" ;
	float variance_ts(time) ;
		variance_ts:long_name = "Variance of ts" ;
		variance_ts:units = "K^2" ;
		variance_ts:missing_value = -9999.f ;
		variance_ts:ancillary_variables = "qc_variance_ts" ;
	int qc_variance_ts(time) ;
		qc_variance_ts:long_name = "Quality check results on variable: Variance of ts" ;
		qc_variance_ts:units = "1" ;
		qc_variance_ts:standard_name = "quality_flag" ;
		qc_variance_ts:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_ts:fail_min = 0.001f ;
		qc_variance_ts:fail_max = 5.f ;
		qc_variance_ts:flag_method = "bit" ;
		qc_variance_ts:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_ts:bit_1_assessment = "Bad" ;
		qc_variance_ts:bit_2_description = "Value is less than fail_min." ;
		qc_variance_ts:bit_2_assessment = "Bad" ;
		qc_variance_ts:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_ts:bit_3_assessment = "Bad" ;
	float variance_co2(time) ;
		variance_co2:long_name = "Variance of co2" ;
		variance_co2:units = "mmol^2/m^6" ;
		variance_co2:missing_value = -9999.f ;
		variance_co2:ancillary_variables = "qc_variance_co2" ;
	int qc_variance_co2(time) ;
		qc_variance_co2:long_name = "Quality check results on variable: Variance of co2" ;
		qc_variance_co2:units = "1" ;
		qc_variance_co2:standard_name = "quality_flag" ;
		qc_variance_co2:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_co2:fail_min = 0.001f ;
		qc_variance_co2:fail_max = 4.f ;
		qc_variance_co2:flag_method = "bit" ;
		qc_variance_co2:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_co2:bit_1_assessment = "Bad" ;
		qc_variance_co2:bit_2_description = "Value is less than fail_min." ;
		qc_variance_co2:bit_2_assessment = "Bad" ;
		qc_variance_co2:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_co2:bit_3_assessment = "Bad" ;
	float variance_h2o(time) ;
		variance_h2o:long_name = "Variance of h2o" ;
		variance_h2o:units = "mmol^2/m^6" ;
		variance_h2o:missing_value = -9999.f ;
		variance_h2o:ancillary_variables = "qc_variance_h2o" ;
	int qc_variance_h2o(time) ;
		qc_variance_h2o:long_name = "Quality check results on variable: Variance of h2o" ;
		qc_variance_h2o:units = "1" ;
		qc_variance_h2o:standard_name = "quality_flag" ;
		qc_variance_h2o:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_h2o:fail_min = 100.f ;
		qc_variance_h2o:fail_max = 150000.f ;
		qc_variance_h2o:flag_method = "bit" ;
		qc_variance_h2o:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_h2o:bit_1_assessment = "Bad" ;
		qc_variance_h2o:bit_2_description = "Value is less than fail_min." ;
		qc_variance_h2o:bit_2_assessment = "Bad" ;
		qc_variance_h2o:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_h2o:bit_3_assessment = "Bad" ;
	float variance_ch4(time) ;
		variance_ch4:long_name = "Variance of ch4" ;
		variance_ch4:units = "nmol^2/m^6" ;
		variance_ch4:missing_value = -9999.f ;
		variance_ch4:ancillary_variables = "qc_variance_ch4" ;
	int qc_variance_ch4(time) ;
		qc_variance_ch4:long_name = "Quality check results on variable: Variance of ch4" ;
		qc_variance_ch4:units = "1" ;
		qc_variance_ch4:standard_name = "quality_flag" ;
		qc_variance_ch4:description = "This variable contains bit-packed integer values, where each bit represents a QC test on the data. Non-zero bits indicate the QC condition given in the description for those bits; a value of 0 (no bits set) indicates the data has not failed any QC tests." ;
		qc_variance_ch4:fail_min = 0.001f ;
		qc_variance_ch4:fail_max = 4.f ;
		qc_variance_ch4:flag_method = "bit" ;
		qc_variance_ch4:bit_1_description = "Value is equal to missing_value." ;
		qc_variance_ch4:bit_1_assessment = "Bad" ;
		qc_variance_ch4:bit_2_description = "Value is less than fail_min." ;
		qc_variance_ch4:bit_2_assessment = "Bad" ;
		qc_variance_ch4:bit_3_description = "Value is greater than fail_max" ;
		qc_variance_ch4:bit_3_assessment = "Bad" ;
	float covariance_w_ts_cov(time) ;
		covariance_w_ts_cov:long_name = "Covariance between w and ts" ;
		covariance_w_ts_cov:units = "(m K)/s" ;
		covariance_w_ts_cov:missing_value = -9999.f ;
	float covariance_w_co2_cov(time) ;
		covariance_w_co2_cov:long_name = "Covariance between w and co2" ;
		covariance_w_co2_cov:units = "mmol/(m^2 s)" ;
		covariance_w_co2_cov:missing_value = -9999.f ;
	float covariance_w_h2o_cov(time) ;
		covariance_w_h2o_cov:long_name = "Covariance between w and h2o" ;
		covariance_w_h2o_cov:units = "mmol/(m^2 s)" ;
		covariance_w_h2o_cov:missing_value = -9999.f ;
	float covariance_w_ch4_cov(time) ;
		covariance_w_ch4_cov:long_name = "Covariance between w and ch4" ;
		covariance_w_ch4_cov:units = "nmol/(m^2 s)" ;
		covariance_w_ch4_cov:missing_value = -9999.f ;
	float co2_signal_strength_7500_mean(time) ;
		co2_signal_strength_7500_mean:long_name = "Mean co2 signal strength" ;
		co2_signal_strength_7500_mean:units = "1" ;
		co2_signal_strength_7500_mean:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "North latitude" ;
		lat:units = "degree_N" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
		lat:standard_name = "latitude" ;
	float lon ;
		lon:long_name = "East longitude" ;
		lon:units = "degree_E" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
		lon:standard_name = "longitude" ;
	float alt ;
		alt:long_name = "Altitude above mean sea level" ;
		alt:units = "m" ;
		alt:standard_name = "altitude" ;

// global attributes:
		:command_line = "ecorsf_ingest -s crg -f S2 -DR" ;
		:Conventions = "ARM-1.3" ;
		:process_version = "ingest-ecorsf-1.3-0.el7" ;
		:dod_version = "ecorsf-b1-1.5" ;
		:input_source = "/data/collection/crg/crgecorsfS2.00/2024-11-29T233000_smart3-00676.zip" ;
		:site_id = "crg" ;
		:platform_id = "ecorsf" ;
		:facility_id = "S2" ;
		:data_level = "b1" ;
		:location_description = "Coast-Urban-Rural Atmospheric Gradient Experiment (CoURAGE), Baltimore, Maryland" ;
		:datastream = "crgecorsfS2.b1" ;
		:doi = "10.5439/1494128" ;
		:history = "created by user dsmgr on machine prod-proc3.adc.arm.gov at 2024-12-03 17:08:16, using ingest-ecorsf-1.3-0.el7" ;
}
